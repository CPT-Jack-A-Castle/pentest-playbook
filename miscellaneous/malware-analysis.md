# Practical Malware Analysis

## Purpose of Malware Analysis

Malware analysis is a form of incident response where understanding the variants of malware and how they behave is key to safe prevention and correct categorization.

Important steps to consider when analyzing malware threats  are: 

* PoE \(Point of Entry\) - Was it a phishing campaign that lead to it? - If that's a probability then checking the email filter and all mail that has pass through is mandatory.
* Are there any indicators of it's executions? Checking files, processes and logs on the machine is vital.
* What is the malware's performance based upon? Does it replicate itself in system or maybe it encrypts files. Some can even install a backdoor or a RAT \(Remote Access Tool\).
* Is there a way to detect and prevent this kind of threat in the future?

## Malware Campaigns

Despite the many variants of malware, attacks can generally be classified into two types: **Targeted** and **Mass Campaign**.

#### Targeted

This class of threats is self explanatory. The malware is designed for a specific target in mind. A  great example of this is the [DarkHotel](https://www.kaspersky.co.uk/resource-center/threats/darkhotel-malware-virus-threat-definition) malware. It's purpose is to steal authentication details from government officials.

#### Mass campaigns

Contrarily, mass campaign threats are the exacts opposite. They infect as many devices as possible, no matter the target. Unfortunately, this is the most common type of threat in real world scenarios. They are also know as "Advanced Persistent Threats" or "APTs". Companies such as Kaspersky track these APT's and often report on their infection rate, similarly like in an event of a pandemic.  

A good example of such a report is [The Crounching Yeti \(Energetic Bear\) report](https://www.kaspersky.co.uk/resource-center/threats/crouching-yeti-energetic-bear-malware-threat). This campaign specifically targets industrial, manufacturing, pharmaceutical and education fields.

The most famous example of a targeted attack is the **Stuxnet** worm. It spread globally infecting millions of machines but did not execute till it reached it's final destinations which was the Nuclear Program of Iran. It caused substantial damage to the plant...

In mass campaigns, the most famous example is the WannaCry virus. It is a type of ransomware that used a vulnerability in windows based systems. The exploit is know as MS17-101 or "Eternal Blue". Hundreds of thousands machines had their data encrypted by this threat. In order to retrieve it, the user had to pay "ransom" to the attackers...

## Attack Identification

Inevitably, due to malware nature, it is largely obtrusive and leaves large amounts of papertrail that can be used for analysis and identification. An attack can be roughly broken down into four steps - Delivery, Execution, Persistence and Propagation. These steps may generate a lot of data such as network traffic and system interactions.

* Delivery - How did the malware get inside the system? Was it due to a phishing campaign or vulnerability enumeration. There are many ways to deliver an attack.
* Execution - What does it do? This is the main way of categorizing threats. If it encrypts files it is a Ransomware, if it records keystrokes it is a Spyware and so on.
* Persistence - Does it do anything after the stage of execution? Some viruses may install a backdoor for further attacks upon the system. This stage generates lots of "noise" that could potentially expose it.
* Propagation - Will it spread to other devices? If a virus is capable of infecting one device, then it could many other as well.

Altogether, there are two main types of fingerprints that may be left after an attack - host-based and network-based.

* Host-based signatures - Installed software, system logs and file modifications can leave important trails for identification.
* Network based signatures - Observation of network communication that took place during delivery, execution and propagation is key to identifying the attacker host.

## Static and Dynamic Analysis

There are two main categories of analysis - **static** and **dynamic**. Each one is essential to the other.  

* **Static analysis** is used to get a high level abstraction of the sample. It is fairly easy to decide whether a source code is malicious with this method alone. At it's core, this method is of the analysis of the sample at the state it presents itself as, without executing the code.
* **Dynamic analysis**, on the other hand, is where the abstraction of the sample is largely built upon. It includes executing the script in a safe environment and analyzing it's behavior.

## Obtaining MD5 Checksums

The **MD5 message-digest algorithm** is a widely used hash function producing a 128-bit hash value. Although MD5 was initially designed to be used as a cryptographic hash function, it has been found to suffer from extensive vulnerabilities. It can still be used as a checksum to verify data integrity, but only against unintentional corruption. It remains suitable for other non-cryptographic purposes, for example for determining the partition for a particular key in a partitioned database.

In the Malware Community, MD5 "Checksums" are a prominent attribute, that allows uniformed identification. They serve as cryptographic fingerprints of the files and help to identify the specific variant of a malware family.

Depending on the environment, there are different tools for calculating checksums. In Windows, there is a tool called [Hashtab](http://implbits.com/products/hashtab/) which calculates a files MD5 sum directly within Windows Explorer upon inspecting it's properties. For Linux and MacOS, there are command line interface tools such as **md5sum** and **md5**, respectively.

Google offers an online service called [Virustotal](https://www.virustotal.com/gui/) to verify checksums with previously analyzed known threats. If there is a file with an unknown origin, the user could verify it's checksum. 

## Obfuscation

Malware obfuscation is a process that makes textual and binary data difficult to understand. It helps adversaries hide critical strings that a program uses because they reveal patterns of the malware’s behavior. Examples of these strings would be registry keys and infected URLs.

Adversaries commonly use encryption/encoding techniques to conceal the data from security programs. Sometimes they go a step further and use special tools called “packers” to obfuscate the entire program, which makes reverse engineering and analysis much more difficult.

Malware creators routinely utilize obfuscation to complicate the detection of their code. Some techniques they commonly use to steer clear of security defenses are - XOR, Code integration, Dead code insertion, Packers, ROT13 and Base64

#### XOR

This popular method of obfuscation conceals data so it cannot be analyzed. It does this by swapping the contents of two variables inside the code.

Another method is to assign junk values, which will compose values that are simply overwritten later on. For example, INC EBX can be overwritten as MOV EBX, 59F67CD5h.

Adversaries can also run comparisons, then ignore the flags that are set. For example, they can compare EAX ESP, run a number of instructions and then finally test EBX, EAX.

Other techniques include adding a value, then modifying it with XOR. For example, XORing with all 1s is not equal to NOT:

* XOR EAX, 0FFFFFFFH
* MOV EBX, 59F67CD5h

Which will be the same as MOV EBX, 0A609832Ah.

Each of these techniques makes the malware difficult to read unless a trained reverse engineer applies 0x55 XOR values to the code.

#### Code integration

First seen in the Zmist/Win95 malware \(known as Zmist\), code integration instructs a malicious code to knit itself to the code of the target program. To apply the technique, the malware first decompiles the program into manageable elements, adding itself between them, and then reassembles the injected code into a new variant.

#### Base64 

Another well-known obfuscation technique utilized by adversaries is Base64. It’s basically an encoding technique that involves 64 characters, with the padding character being the = \(equal\) sign. Characters a-z, A-Z, + and /, and 0-9 are also present in the alphabet.

The encoding functions by taking 3 characters and stringing them with each other to create a 24-bit string that’s later broken into 4 chunks of 6-bits, which are then translated into one of the characters from Base64. The technique is trivial to decode if it can be recognized.

#### Dead code insertion

Dead code insertion is a rudimentary tactic that inserts some ineffective code into a program to modify its appearance. However, it doesn’t alert the program’s behavior. For combating the insertion, signature-based antivirus solutions need to wipe off the instructions before conducting analysis. 

#### ROT13 

Another popular malware obfuscation technique is ROT13. It leverages simple letter substitution for delivering an obfuscated output, where ROT acts as an ASM instruction that says “rotate.” Hence, ROT13 is another name for “rotate 13.”

Adversaries, therefore, would need to rotate a letter by thirteen to encode it, which means they would need to count the next 13 letters of the alphabet until they reach “n.” ROT13 capitalizes on a simple letter substitution for jumbling the text. It can also be configured to rotate a distinctive number of characters, such as ROT15.

#### Packers

In many instances, the whole program is obfuscated to keep everyone from detecting the malware code until it is inserted in memory. This is done with the help of software, which compresses an executable to reduce its size. It then packages the compressed executable inside the code required to decompress itself at runtime. The process of decompression ensures the executive file doesn’t look anything like its original self.

Even though there are legitimate benefits of using packers, such as reducing the size of the executables or making it difficult for pirates to engage in reverse engineering, malware often leverages packed executables to attempt to hide from security defenses. Malware creators may also develop custom packers that defeat unpacking scripts and forces reverse engineers to unpack the program to see what it is doing.

#### Conclusion

For as long as malware thrives, so too will obfuscation. Adversaries know that it’s a highly reliable technique that everyday users can do little about. With that said, it is crucial for organizations to take proactive measures for timely detection and analysis. One of the first steps toward better defenses is to familiarize yourself with the latest techniques threat actors are leveraging.

## Sources

* [What is Malware Obfuscation?](https://resources.infosecinstitute.com/topic/what-is-malware-obfuscation) by Dan Virgillito, February 5, 2020

